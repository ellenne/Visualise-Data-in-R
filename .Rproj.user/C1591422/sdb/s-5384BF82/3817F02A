{
    "collab_server" : "",
    "contents" : "---\ntitle: \"MyNotes\"\nauthor: \"Luigi Neri\"\ndate: \"16 September 2017\"\noutput: md_document\n---\n\n# Instalation of the packages needed for the work\n\n```{r setupFirst}\nknitr::opts_chunk$set(echo = FALSE)\nlibrary(tidyverse)\nlibrary(socviz)\nlibrary(gapminder)\n```\n\n```{r setup, eval=FALSE}\nmy_packages <- c(\"tidyverse\", \"broom\", \"coefplot\",\"cowplot\",\n                 \"gapminder\", \"GGally\", \"ggrepel\", \n                 \"ggridges\", \"gridExtra\", \"interplot\",\n                 \"margins\", \"maps\", \"mapproj\", \"mapdata\",\n                 \"MASS\", \"quantreg\", \"scales\", \"survey\",\n                 \"srvyr\", \"viridis\", \"viridisLite\",\n                 \"devtools\")\n\ninstall.packages(my_packages,\n                 repos = \"http://cran.rstudio.com\")\n```\n\n## one other special package is required\n\n\n```{r eval=FALSE}\ndevtools::install_github(\"kjhealy/socviz\")\nlibrary(tidyverse)\nlibrary(socviz)\n```\n\n# Basics of the R language\n\n```{r}\nc(1, 2, 3, 1, 3, 5, 25)\n```\n\n```{r}\nmy_numbers <- c(1, 2, 3, 1, 3, 5, 25)\nyour_numbers <- c(5, 31, 71, 1, 3, 21, 6)\n\n```\n\n## There is a shortcut for the assignment operator that is ## ALT + -\n\n## Functions\n```{r}\nmean(x = my_numbers)\nmean(x = your_numbers)\nmy_summary <- summary(my_numbers)\ntable(my_numbers)\nsd(my_numbers)\nmy_numbers * 2 \nmy_numbers + 1\nmy_numbers + my_numbers\n```\n\n## You can always ask the class\n\n```{r}\nclass(my_numbers)\nclass(my_summary)\nclass(summary)\n```\n\n\nThe class of the R objects can change as per below:\n\n```{r}\nmy_new_vector <- c(my_numbers, \"Apple\")\nmy_new_vector\nclass(my_new_vector)\n```\n\nNote that in my_new_vector the numbers became characters therefore they cannot be used as they are to make calculations. They need to be converted back into numbers.\n\n# Data Frame\n\n```{r}\ntitanic\n```\n```{r}\nclass(titanic)\n```\n\n\nIn order to access to the data frame variables we use the dollar operator ($)\n\n```{r}\ntitanic$percent\n```\n\n# To see inside an object\n \nThe str function is very useful\n\n```{r}\nstr(my_numbers)\nstr(my_summary)\n```\n\nLet's start\n\n```{r}\nlibrary(gapminder)\nhead(gapminder)\n```\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap, y = lifeExp))\np + geom_point()\n```\n![](figures\\Chart_01.png)\n## Let's look at the data\n\n```{r}\ndata(anscombe)\nlibrary(gapminder)\np <- ggplot(data = gapminder)\n```\n\nWe know the data but not the mapping \n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp))\n```\n\nThe geometry is missing and we add it like that \n\n```{r}\np + geom_point()\n```\n![Figure 2](figures\\Chart_02.png)\nWe can add a trend line like that :\n\n```{r}\np + geom_smooth()\n```\n![Figure 3](figures\\Chart_03.png)\n\nOnly the line is showed. If I want to show the points and the line, I have to put both in my chart like this:\n\n```{r}\np + geom_point() + geom_smooth()\n```\n![Figure 4](figures\\Chart_04.png)\n\nThe function of the trend has been automatically chose by R. If I want to specify the function as a line I can do the following:\n\n```{r}\np + geom_point() + geom_smooth(method = \"lm\")\n```\n![Figure 5](figures\\Chart_05.png)\nIf I want to change the scale and instead of plot x and y I want to plot them on a Log10 scale I can do the following (first version is the explicit declaration then a function is used)\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = log10(gdpPercap),\n                          y = lifeExp)\n            )\np + geom_point() +\n  geom_smooth(method = \"gam\")\n```\nIn the case above the GAM function is used in the smooth. This is used to fit a Generalized Additive Model.\n\nThat should be equivalent to this:\n\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp)\n            )\np + geom_point() +\n  geom_smooth(method = \"gam\") +\n  scale_x_log10()\n```\nThe only difference is in the scale. Above I had the value of the Log. In the second case instead I have the value de-logged.\n\nOther useful transformation can be the following:\n\nscale_x_sqrt()\nscale_x_reverse()\n\nLet's try them both:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp)\n            )\np + geom_point() +\n  geom_smooth(method = \"gam\") +\n  scale_x_sqrt()\n```\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp)\n            )\np + geom_point() +\n  geom_smooth(method = \"gam\") +\n  scale_x_reverse()\n```\n\nIf we haven't loaded a library and we want to use a component of that library we use the following syntax thelibrary::thefunction as in the below:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap, y = lifeExp))\np + geom_point() +\n    geom_smooth(method = \"gam\") +\n    scale_x_log10(labels = scales::dollar)\n```\nA part from scales::dollar we have other function that we can use such as scale::commas that we will try here below:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap, y = lifeExp))\np + geom_point() +\n    geom_smooth(method = \"gam\") +\n    scale_x_log10(labels = scales::comma)\n```\n\nNow we can add more variables to our plot. Let's see how:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp,\n                          color = continent))\n\np + geom_point() + geom_smooth() + \n    scale_x_log10(labels = scales::dollar)\n\n```\nThe plot is very difficult to read and also there are 5 smoothers, one foreach continent. \nThis was my own plot, the book did not trace it.\n\nLet's go back to what the book trace:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp,\n                          color = \"purple\"))\np + geom_point() +\n    geom_smooth(method = 'loess') +\n    scale_x_log10()\n```\nThe legend there is because we added the colour in the wrong place. Putting it into the aes R reclycle the string, makes it a vector on the fly so a new dimension is created similar to what happened before with the continent. \n\nRemember that the purple is the colour of the points so let's put it in the right place as below:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp))\np + geom_point(color = \"purple\") +\n    geom_smooth(method = 'loess') +\n    scale_x_log10()\n```\nAttributes that are not typical of the mapping of the plot do not go inside the aes function. Here below we set some parameters belonging to smooth function. The se function switches of the standard error around the trend line. The size is very high (to have a very thick line) and the method is lm.\nNote that all these have been specified within the smooth outside the mapping that is concerned just with what it has to be mapped on the chart (the coordinates of the points)\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap, y = lifeExp))\np + geom_point(alpha = 0.3) +\n    geom_smooth(color = \"orange\", se = FALSE, size = 8,\n                method = \"lm\")+\n    scale_x_log10()\n```\n\nNow we can make a polished plot\n\n```{r}\np <- ggplot(data = gapminder, \n            mapping = aes(x = gdpPercap, y = lifeExp))\np + geom_point(alpha = 0.3) +\n    geom_smooth(method = \"gam\") + \n    scale_x_log10(labels = scales::dollar) +\n    labs(x = \"GDP Per Capita\",\n         y = \"Life Expectancy in Years\",\n         title = \"Economic Growth and Life Expectancy\",\n         subtitle = \"Data points are country-years\",\n         caption = \"Source: Gapminder.\")\n```\n\nWe can add in our chart the information about the Continent as well:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp,\n                          color = continent,\n                          fill = continent))\np + geom_point() +\n    geom_smooth(method = 'loess') +\n    scale_x_log10()\n```\nThe problem with the chart above is that is very confused. We have 5 lines that are a little bit too many. \n\nWe can avoid it. Maybe just one line would be enough.\nThis happens because the geom_ functions inherit the mapping from the ggplot function that is in the layer above. But we can modify this redefying the mapping in the geom_ as well.\n\nSo we will not specify the color and fill in the ggplot function but in the geom_ we will say that we want the points colored by continent in this way:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp))\np + geom_point(mapping = aes(color = continent)) +\n    geom_smooth(method = 'loess') +\n    scale_x_log10(labels = scales::dollar)\n```\n\nIt is possible to map continuous variables to colors as well. Note that the continent is a discrete or categorical variables (that assumes a small number of values). \nWe are going to see it with Population (pop). It is better to cut a continuous variable into bins rather than using a colour.\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = gdpPercap,\n                          y = lifeExp))\np + geom_point(mapping = aes(color = pop)) +\n    scale_x_log10()\n```\n\n# Group, facets and transform\n\n## Group\n\nWe want to plot the trajectory of life expectancy over time for each contry. We want to see that as years pass life expectancy increases. Year will be our X variable and lifeExp Y. \n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = year,\n                          y = gdpPercap))\np + geom_line()\n```\nThis is not what we expected. Our data are for each contry, so we need to tell this to ggplot.\nWhat ggplot is doing is the following: it finds a series of year observations (e.g 1952 Afganistan, 1952 USA, 1952 Italy) and put them all together. So it seems that we do not have some numbers of observations by each year.\n\nWhen ggplot gives a chart that is wrong but without an error being produced it means that there is a mismatch between the data and the aesthetics for the geometry being used. Therefore in the geom_ we need to redefine, customize the aesthetics in order for R doing what we want.\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = year,\n                          y = gdpPercap))\np + geom_line(aes(group = country))\n```\n\nThe outlier is Kuwait.\n\nThe previous with the previous plot was that ggplot could not know that the year was grouped by country and this is what we tell in the geom_ aesthetic.\n\nSimilar we can do:\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = year, y = lifeExp))\np + geom_line(aes(group = country))\n```\n\n## Facet\n\nThe charts above are powerful but they are pretty unreadable. So we can use facets, produce many little charts that we put back to back or organise in a matrix to highlight differences.\n\nFacets is not a geom_ but a way to organise geometries. We use facet_wrap. Many arguments can be used but the most important is the first one - the R formula which use the tilde char ~\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = year,\n                          y = gdpPercap))\np + geom_line(aes(group = country)) +\n    facet_wrap(~ continent)\n```\nLet's try to put all in one line with the trend line in each plot\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = year, y = gdpPercap))\np + geom_line(color = \"gray70\", aes(group = country)) +\n    geom_smooth(size = 1.1, method = \"loess\", se = FALSE) +   scale_y_log10(labels = scales::dollar) +\n    facet_wrap(~ continent, ncol = 5) +\n    labs(x = \"Year\",\n         y = \"GDP per capita\",\n         title = \"GDP per capita on Five Continents\")\n  \n```\nFacets can do more that that. It is possible to cross-classify some data by two categorical variables. In this case you use facet_grid(). The plot will be laid in a true two-dimensional arrangement.\n\nWe can see this on the diamonds dataset\n\n```{r}\np <- ggplot(data = diamonds, \n            mapping = aes(x = carat, y = price))\np + geom_smooth(alpha = 0.3) +\n    facet_grid(cut ~ color)\n```\nWe have 2 variables the cut (fair, good, fairy good, premium, ideal) and the color (D, E, F, G, H, I, J). For each of the 35 combinations facet_grid makes a chart of the carat vs price.\n\nFurther CATEGORICAL variables can be added (e.g cut ~ color + clarity)\nThere is a difference if you write the formula like that cut ~ color or ~ cut + color\n\n```{r}\np <- ggplot(data = diamonds, \n            mapping = aes(x = carat, y = price))\np + geom_smooth(alpha = 0.3) +\n    facet_grid(~ cut + color)\n```\n\n## Geom\n\nEvery geom_ function has an associated stat_ function that it uses by default\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = continent))\np + geom_bar()\n```\nThe chart above represent the count by continent of the points. This is because the bar has the stat_count as default.\n\nWe need to notice that the y-axis contains the variable 'count' that is not in the data. Ggplot is counting the couple year-country for us automatically. This is done using the stat_ function associated with it in this case stat_count(). This function has computed 2 new vars count and prop (proportion).\nstat_count is used by default by geom_bar()\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = continent))\np + geom_bar(mapping = aes(y = ..prop..))\n```\n\nThe .. before and after the variable names is to make sure these variables are not confused with others that can possibly exist.\n\nWe are trying to make a chart with the proportion of observations per country. What is happening with the chart above is that the denominator is the number of observation by contient, that's why it is always giving us 100%. It is the opposite problem of the grouping because we need to tell R to consider as denominator the total number of observations. So we need to tell ggplot to ignore the x category when calculating the denominator of the proportion and use the total. \nWe do that using group = 1 inside the aes call. 1 is a dummy value to say to use the whole dataset when establishing the denominator for the proportion\n\n```{r}\np <- ggplot(data = gapminder,\n            mapping = aes(x = continent))\np + geom_bar(mapping = aes(y = ..prop.., group = 1))\n```\n\nIn order to show other function of geom_bar we will use another dataset containing more categorical variables.\nThis is the General Social Survey (GSS). It is in the socviz package. We see the results of the question what is your religion:\n\n```{r}\ntable(gss_sm$religion)\n```\n\nWe want a bar chart coloured by religion. So religion should be in the fill. \n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = religion, color = religion))\np + geom_bar()\n```\n\nWe need to remember that mapping religion to color will just give the color to the external shape but the inside will stay gray. If we want to fill we need to use fill \n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x= religion, fill = religion))\np + geom_bar() + guides(fill = FALSE)\n```\nguides(fill = FALSE) helps the name not to go one over the other. Also the legend is removed. The legend is there because we mapped the same variable (religion) on 2 aesthetics (x and color/fill).\n\nThe fill aesthetics can be used to show 2 variables at once.\nThe dataset has another variable called big region that can be broken down by religion in this way:\n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = bigregion, fill = religion))\np + geom_bar()\n```\n\nIt is difficult to see the position of the Catholics in the different regions therefore we can do as follow:\n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = bigregion, fill = religion))\np + geom_bar(position = \"fill\")\n```\n\nIf we want stacked bars we use dodge:\n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = bigregion, fill = religion))\np + geom_bar(position = \"dodge\")\n```\n\nWe loose the proportion because the count takes over so we can use the very same trick we used above:\n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = bigregion, fill = religion))\np + geom_bar(mapping = aes(y = ..prop..),\n             position = \"dodge\")\n```\n\nWe need to say that the denominator of the proportion should be the total and not what there is in the bigregion. We do that using group. We want that the sum of the percentages in each bigregion is 100% so religion should be the variable we group by in order to calculate the proportions.\n\n```{r}\np <- ggplot(data = gss_sm,\n            mapping = aes(x = bigregion, fill = religion))\np + geom_bar(mapping = aes(y = ..prop.., group = religion),\n             position = \"dodge\")\n```\n\nThe above is not quite right because the objective was not achieved. In fact if you sum the percentages within big region you do not get to 100% but you get to 100% if you sum the same religion across the big regions. This is what we said when we said group = religion (if catholics are 100 across the 4 regions give me the percentage). We should group by 2 things, the religion and the big region. So if I have 100 in the Northeast and 50 are catholic is do 50/100. \n```{r}\ntable(gss_sm$bigregion, gss_sm$religion)\n```\n\nIf we want to calculate the percentages, there is some work to do but eventually we arrive there:\n```{r}\nt1 <- table(gss_sm$bigregion, gss_sm$religion)\nt2 <- as.matrix(prop.table(t1, 2))\n\n\nt3 <- matrix(data = sprintf(\"%.1f %%\", 100*t2), ncol = 5, nrow = 4)\nrow.names(t3) <- rownames(t2)\ncolnames(t3) <- colnames(t2)\nt3\n```\n\n",
    "created" : 1505585565403.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1857030217",
    "id" : "3817F02A",
    "lastKnownWriteTime" : 1506803983,
    "last_content_update" : 1506803983228,
    "path" : "~/R/Visualise Data in R/viznotes.Rmd",
    "project_path" : "viznotes.Rmd",
    "properties" : {
        "last_setup_crc32" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}